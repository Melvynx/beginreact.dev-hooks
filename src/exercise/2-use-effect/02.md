# useEffect

useEffect est le hooks le plus compliquÃ©.

Il va gÃ©rer le life cycle de ton application.

Mais c'est quoi le life-cycle ?

Voici un graphique pour le comprendre :

<img src="../../../public/assets/react-hooks-flow.png" alt="react hooks flow" />

Dans la vidÃ©o Intro, je t'explique un peu ce graphique. Mais dans l'extra 7
on va comprendre sur le terrain comment Ã§a fonctionne.

`useEffect` permet de savoir :

- quand un state change
- quand le composant est montÃ© (`onMount`)
- quand le composant est dÃ©montÃ© (`onUnmount`)
- quand le composant change (`onChange`)

```js
useEffect(() => {
  console.log('create');
  return () => {
    console.log('destroy');
  };
}, [dependencies]);
```

âš ï¸ Comme son nom l'indique, il permet de gÃ©rer les `side effect`.

Mais c'est quoi un `side effect` ?

Il permet de garder ton composant synchronisÃ© avec des systÃ¨mes externes.
(browser APIs ex: localStorage, third-party libraries, network, etc...)

Pour update un state basÃ©s sur un autre state tu n'as pas besoin d'avoir de useEffect.

- [ğŸ“– useEffect](https://react.dev/reference/react/useEffect)

## Exercice - Local storage

Dans le composant `Hello`, on veut que le `name` soit gardÃ© dans le `localStorage`
afin de ne pas le perdre quand on recharge la page.

Pour Ã§a Ã©coute Lienx ğŸ¦ dans le fichier Exercice.

ğŸ’Œ Tu comprends l'utilisation basique du `useEffect`.

## Extra 2 - Optimisation

Notre client rencontre des difficultÃ©s, notre application rÃ©cupÃ¨re tout le temps la valeur
dans le localStorage (Ã  chaque render).

De plus, le code mis dans la defaultValue du useState est pas top top...

DÃ©place cette logique dans une fonction `getInitialName` et utilise la dans le useState.

Remplace la valeur par dÃ©faut par une arrow function. (ğŸ’¡ `useState(() => ...)`)

Effectivement `useState` peut prendre une fonction en paramÃ¨tre pour initialiser
la valeur par dÃ©faut.

On comprendra dans la solution l'avantage de cette fonction !

En plus, il s'est rendu compte que quand on clique sur le Counter, le `useEffect`
est appelÃ©. Tu dois ajouter des dÃ©pendances Ã  notre `useEffect`
pour Ã©viter de l'appeler Ã  chaque render.

Car on change l'item dans le local storage mÃªme quand Ã§a ne sert Ã  rien.

ğŸ’Œ Tu comprends comment fonctionne l'initial value du `useState`.
ğŸ’Œ Tu comprends l'utilitÃ© des dÃ©pendances dans le `useEffect`.

## Extra 3 - Refactor

DÃ©place toute la logique qui concerne le state et le local storage dans un custom hook.

Pour Ã§a, il te suffit de crÃ©er une fonction qui se nomme `useStickyState` et de
dÃ©placer la logique (comme on l'a vue pour le `useHistory` de l'exercice prÃ©cÃ©dent).

`useStickyState` va retourner : `[state, setState]` pour garder la mÃªme API que `useState`.

ğŸ’Œ Tu comprends comment fonctionnent les custom hooks.

## Extra 4 - Remplacer le useEffect

Le `useEffect` est devenu inutile, car il permet de tracker un side effect.

Hors ici ce n'est plus un side effect car on sait exactement quand notre state est
modifiÃ©.

Pour gÃ©rer le local storage, on va crÃ©er une fonction `setValue` dans laquelle on va
changer le state, mais aussi update le local storage.

`setValue` est une fonction Ã  l'intÃ©rieur de `useStickyState`. Dans la valeur de retour
tu peux remplacer `setState` par `setValue` pour garder la mÃªme API. (attention `setState`
peut prendre une fonction en paramÃ¨tre, il faut gÃ©rer ce cas dans `setValue`)

âš ï¸ Le `useEffect` a sa place ici, je fais cet exercice pour que tu te rendes
compte des possibilitÃ©s et comprenne comment tu peux remplacer le `useEffect`

ğŸ’Œ Tu comprends que l'usage du `useEffect` peut parfois Ãªtre remplacÃ©.

## Extra 5 - Nouvelle feature !

Le client souhaite que le Counter s'incrÃ©mente automatiquement quand la taille de la fenÃªtre change.

Pour Ã§a il va falloir ajouter un `useEffect` dans le composant `App`.

ğŸ’¡ Pour dÃ©buter

```js
useEffect(() => {
  const handleResize = () => {
    // ...
  };
  window.addEventListener('resize', handleResize);
  return () => {
    // clean up function
  };
});
```

âš ï¸ Cet exercice est un dÃ©fi. Si tu le rÃ©ussis facilement tant mieux, sinon regarde
la vidÃ©o de solution.

ğŸ’Œ Tu apprends l'utilisation de la clean up function.

## Extra 6 - Refactor

Maintenant, notre composant App **entiÃ¨re** rerender quand la fenÃªtre change. C'est une trÃ¨s
mauvaise pratique, car Ã§a ralenti notre navigateur.

La solution est de dÃ©placer la logique du Counter et du listener qui Ã©coute les changements
de la taille de la fenÃªtre dans un composant.

Car uniquement le bouton a besoin de savoir quand la taille de la fenÃªtre change. Pas notre composant `NameInput`.

ğŸ’Œ Tu apprends Ã  correctement sÃ©parer ton code pour Ã©viter de ralentir ta page.

## Extra 7 - Pas tout le temps !

Notre bouton sâ€™incrÃ©mente lorsque la page grandit.

Dans le composant `Counter`, rajoute une checkbox et fais en sorte
que le bouton s'incrÃ©mente seulement quand la checkbox est cochÃ©e.

Il faudra rajouter une condition pour le `useEffect`.

ğŸ’¡ Utilise `useState` !

ğŸ’Œ Tu comprends comment lancer des effets conditionnellement.

## Solution 8 - EXPLICATION DU HOOKS FLOW

âš ï¸ Ceci n'est pas un exercice. Tu peux directement regarder la vidÃ©o solution. âš ï¸
