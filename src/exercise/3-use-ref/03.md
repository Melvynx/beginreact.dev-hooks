# useRef

Nous avons dÃ©jÃ  vu les useRef dans le cas des formulaires. C'Ã©tait pour rÃ©cupÃ©rer
la valeur d'un input afin de pouvoir le submit.

```jsx
const Component = () => {
  const inputRef = useRef();

  return <input ref={inputRef} id="example" />;
};
```

Quand tu fais Ã§a, tu viens simplement rÃ©cupÃ©rer la rÃ©fÃ©rence **dans le DOM** de l'Ã©lÃ©ment.
Ici, la valeur d'`input.current` c'est comme si tu faisais `document.querySelector("#example")`.

[ğŸ“– useRef - RÃ©cupÃ©rer un Ã©lÃ©ment du DOM](https://react.dev/reference/react/useRef)

Mais `useRef` a une deuxiÃ¨me utilitÃ© : pour [ğŸ“– rÃ©fÃ©rencer des valeurs](https://react.dev/reference/react/useRef#referencing-a-value-with-a-ref)
qui sont mÃ©morisÃ©es entre les renders.

C'est ce cas que l'on verra dans cet exercice.

[ğŸ“– Mon article sur useRef](https://codelynx.dev/posts/comment-utiliser-useref) (Ã  lire aussi de ton cotÃ©)

## Exercice - useDebounce

Nous avons une petite application qui, lorsque tu rentres ton prÃ©nom, te dit : "l'Ã¢ge de <ton prÃ©nom>".

Pour ce faire, on va utiliser une API qui se nomme [agify](https://agify.io/).

Je te laisse check la documentation. Notre application a des inputs, et on veut
que notre application affiche l'Ã¢ge du prÃ©nom inscrit dans l'input. Comme si c'Ã©tait
une searchbar â†’ pas de button submit.

Tu Ã©cris â†’ on fetch â†’ on affiche la rÃ©ponse.

Le problÃ¨me, c'est que l'on ne veut pas fetch 10000x l'api. On souhaite le faire **quand tu as fini d'Ã©crire**.
Comment savoir quand tu as fini d'Ã©crire ?

On va dire qu'Ã  partir du moment oÃ¹ tu n'Ã©cris plus depuis **500ms**, c'est que
tu as terminÃ© d'Ã©crire. Ã€ ce moment-lÃ , on va fetch la nouvelle donnÃ©e.

En JavaScript, on appelle ce genre de fonctionnalitÃ© un **debounce**.

[ğŸ“– Comprendre le debounce](https://css-tricks.com/debouncing-throttling-explained-examples/)

Tu vas crÃ©er le hook `useDebounce` qui va prendre deux paramÃ¨tres, la `callback` function
ainsi que `time` en milliseconds.

Il va retourner une fonction que l'on va nommer `onDebounce`. Les consignes sont dans l'exercice.

ğŸ’Œ Tu comprends comment stoker des valeurs qui n'influent pas le render dans des useRef

## Extra 2 - Input ref

Dans un but pÃ©dagogique, ajoute une `ref` nommÃ©e `inputRef` afin de rÃ©cupÃ©rer
la valeur de l'input.

Remplace la logique de `value` dans notre fonction `onSearch` avec
la valeur stockÃ©e dans la `ref` `inputRef`.

ğŸ’Œ Tu comprends que la ref permet aussi de rÃ©fÃ©rencer un Ã©lÃ©ment du DOM.

## Extra 3 - Render count

En utilisant ce que l'on a appris avec les render dans l'exercice sur les `useEffect`,
crÃ©e un hooks `useRenderCount` pour calculer le nombre de render qu'on fait subir
Ã  notre composant.

ğŸ’¡ CrÃ©e un hooks `useRenderCount` avec une ref qui est incrÃ©mentÃ©e Ã  chaque render.

ğŸ’¡ Tu peux ensuite afficher `ref.current` dans la vue pour voir le nombre de render.

ğŸ’Œ Tu comprends que les rÃ©fÃ©rences sont dissociÃ©es des render.
