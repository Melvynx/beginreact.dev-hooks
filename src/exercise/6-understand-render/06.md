# Render

Un des plus gros problÃ¨mes des Ã©lÃ¨ves sont les `renders` en React.
Dans ce chapitre, on va voir **trÃ¨s briÃ¨vement** le hooks `useMemo` et `useCallback`
ainsi que la mÃ©thode `memo`.

On va aussi re-dÃ©couvrir le `Profiler` qui est un outil sous-cotÃ©s de React.
Les render ne sont pas si compliquÃ©s Ã  comprendre. J'ai imaginÃ©
des exercises pour te faire les comprendre.

#### DÃ©jÃ , quand un `render` se produit ?

Tout simplement quand un state, comme `useState` ou `useReducer`, est modifiÃ©.
Quand tu appelles la fonction `setState` ou `dispatch` tu lances un render.
S'il y a un changement de state (valeur diffÃ©rente) React va lancer
le render de ton composant. _(si tu set le mÃªme state, il ne se passe rien)_

Dans le cas d'un `useContext`, **tous les "consumers"** vont rerender
quand la props `value` de `Context.Provider` est modifier.

#### Dans quel cas un composant rerender ?

1. Quand son parent rerender, **tous les enfants sont rerender**.
2. Quand un Ã©tat change, le composant lui-mÃªme rerender.
3. Quand ton composant consomme un context dont la valeur Ã  Ã©tÃ© changÃ©

âŒ Non ce n'est pas quand une **props** change que le composant est rerender !

Je prÃ©cise qu'un state qui change, qu'il soit dans un hooks qui est dans un hooks
qui est dans un hooks et que ton composants utilise ferra la mÃªme chose.

[ğŸ“– Blog post pour comprendre les render](https://www.developerway.com/posts/react-re-renders-guide)

Les props n'ont aucun rÃ´le dans le render. Quel change ou pas
les enfants vont rerender.

Sauf en utilisant `memo` qui permet de crÃ©er des `Pure Component`
ce qui empÃªche le rerender (on le voit dans l'extra 2).

Mais attention, dans les exercises on l'utilise pour apprendre, **mais
il ne faut surtout pas l'utiliser pour chaque composant qui rerender
avant qu'il y ai des bugs.**

`memo` est lÃ  pour rÃ©soudre des problÃ¨mes, pas pour prÃ©parer la
rÃ©solution de problÃ¨mes.

Il y a des dizaines de solutions pour Ã©viter des rerender juste dans
l'architecture de nos composants.

Pour pouvoir en voir un maximum, cette exercise est composÃ© d'exercise
diffÃ©rent, tu trouveras dans ce dossier 5 exercises diffÃ©rent (toujours
dans un fichier sÃ©parer)

## Exercise - SÃ©parer, composer, splitter

Il faut sÃ©parer un maximum ses composants ! Le but d'un framework comme
React est de sÃ©parer la logique tout le temps. Ici l'app possÃ¨de un state,
c'est une erreur, car seul 1 des enfants la consommes. Il faut donc sÃ©parer
le state dans un nouveau composant `Counter`.

ğŸ’¡Pour t'aider j'ai "highlight" les composants qui sont rerender
en vert !

Comme tu le vois chaque fois que tu cliques sur le counter,
le `Header` et le `Footer` rerender.

ğŸ’Œ Tu comprends l'importance de sÃ©parer les composants

## Extra 2 - Memo

Cette formation est pour les dÃ©butants, `Memo` commence Ã  devenir complexe
mais je te partage quand mÃªme son usage.

Dans l'application a deux input, un pour l'age et l'autre pour le username
gÃ©rer dans le mÃªme `useState`.

Deux composants distincts affiche ces composants : `Age` et `Username`.

Quand je modifie l'Ã¢ge, le `Username` rerender aussi et je ne veux pas
que ceci se produise.

Ta mission est de transformer le composant `Age` et `Username` en un
`PureComponent` en utilisant [memo](https://fr.reactjs.org/docs/react-api.html#reactmemo)

[ğŸ“– Comprendre le memo](https://www.joshwcomeau.com/react/why-react-re-renders/#creating-pure-components)

ğŸ’Œ Tu comprends l'utilisation de `memo`

## Extra 3 - Composant dans un composant !

Voici un anti-pattern trÃ¨s gÃªnant !

Il **ne faut jamais mettre un composant dans un autre composant** en
utilisant la syntaxe que j'ai utilisÃ© dans l'`06.extra.3.jsx` !

Regarde : change la valeur de l'input puis clique sur le bouton !

Boom ğŸ’¥ la valeur est redevenus ce quel Ã©tait.

Il faut donc mettre le composant `HeaderInput` en dehors du composant
`Header`.

ğŸ’Œ Tu comprends pourquoi il ne vaut pas instancier des composants dans des composants.

## Extra 4 - Children

On l'a dÃ©jÃ  vue dans l'exercise du `useEffect` mais j'ai envie de le
souligner.

Encore une fois il faut **abuser** de la crÃ©ation de composant.

Ici chaque fois que la page est scroll toute notre app est rerender
alors que uniquement le bouton change.

Pour que tu vois le lag j'ai crÃ©e un composant qui gÃ©nÃ¨re 10'000 nombre
alÃ©atoire Ã  chaque render. Tu verras que ton navigateur n'aime pas trop...

Tu peux crÃ©e un composant `ScrollComponent` qui contient deux props :

- `topChildren`
- `children`

Et tu peux donc remplacer notre app avec ses composant et mettre `SmallComponentTop`
ainsi que `ExpensiveComponent` dans les props.

## Extra 5 - Profiler
