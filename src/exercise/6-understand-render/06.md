# Render

Un des plus gros problÃ¨mes des Ã©lÃ¨ves est les `renders` en React.
Dans ce chapitre, on va voir **trÃ¨s briÃ¨vement** les hooks `useMemo` et `useCallback`
ainsi que la mÃ©thode `memo`.

On va aussi re-dÃ©couvrir le `Profiler` qui est un outil sous-cotÃ© de React.
Les render ne sont pas si compliquÃ©s Ã  comprendre. J'ai imaginÃ©
des exercices pour te les faire comprendre.

#### DÃ©jÃ , quand est ce qu'un `render` se produit ?

Tout simplement quand un state, comme `useState` ou `useReducer`, est modifiÃ©.
Quand tu appelles la fonction `setState` ou `dispatch` tu lances un render.
S'il y a un changement de state (valeur diffÃ©rente) React va lancer
le render de ton composant. _(si tu set le mÃªme state, il ne se passe rien)_

Dans le cas d'un `useContext`, **tous les "consumers"** vont rerender
quand la props `value` de `Context.Provider` est modifiÃ©e.

#### Dans quel cas un composant rerender ?

1. Quand son parent rerender, **tous les enfants sont rerender**.
2. Quand un Ã©tat change, le composant lui-mÃªme rerender.
3. Quand ton composant consomme un context dont la valeur Ã  Ã©tÃ© changÃ©e

âŒ Non ce n'est pas quand une **props** change que le composant est rerender !

Je prÃ©cise qu'un state qui change, qu'il soit dans un hook qui est dans un hook
qui est dans un hook et que ton composant utilise fera la mÃªme chose.

[ğŸ“– Blog post pour comprendre les render](https://www.developerway.com/posts/react-re-renders-guide)

Sauf en utilisant `memo` qui permet de crÃ©er des `Pure Component`
ce qui empÃªche le rerender (on le voit dans l'extra 2).

Mais attention, dans les exercices on l'utilise pour apprendre, **mais
il ne faut surtout pas l'utiliser pour chaque composant qui rerender
avant qu'il y ait des bugs.**

`memo` est lÃ  pour rÃ©soudre des problÃ¨mes, pas pour prÃ©parer la
rÃ©solution de problÃ¨me.

Il y a des dizaine de solutions pour Ã©viter des rerender juste dans
l'architecture de nos composants.

Pour pouvoir en voir un maximum, cet exercice est composÃ© d'exercices
diffÃ©rents, tu trouveras dans ce dossier 5 exercices diffÃ©rents (toujours
dans un fichier sÃ©parÃ©)

#### RÃ¨gles Ã  suivre

> Garder le state le plus proche de son utilisation

> Garder le code le plus simple possible (KISS)

## Exercice - SÃ©parer, composer, splitter

Il faut sÃ©parer un maximum ses composants ! Le but d'un framework comme
React est de sÃ©parer la logique tout le temps. Ici l'app possÃ¨de un state,
c'est une erreur, car seul 1 des enfant la consomme. Il faut donc sÃ©parer
le state dans un nouveau composant `Counter`.

ğŸ’¡ Pour t'aider, j'ai "highlight" les composants qui sont rerender
en vert !

Comme tu le vois chaque fois que tu cliques sur le counter,
le `Header` et le `Footer` rerender.

ğŸ’Œ Tu comprends l'importance de sÃ©parer les composants

## Extra 2 - Memo

Cette formation est pour les dÃ©butants, `Memo` commence Ã  devenir complexe
mais je te partage quand mÃªme son usage.

Dans l'application a deux inputs, un pour l'Ã¢ge et l'autre pour le username
gÃ©rÃ©s dans le mÃªme `useState`.

Deux composants distincts affichent ces composants : `Age` et `Username`.

Quand je modifie l'Ã¢ge, le `Username` rerender aussi et je ne veux pas
que ceci se produise.

Ta mission est de transformer le composant `Age` et `Username` en un
`PureComponent` en utilisant [memo](https://fr.reactjs.org/docs/react-api.html#reactmemo)

[ğŸ“– Comprendre le memo](https://www.joshwcomeau.com/react/why-react-re-renders/#creating-pure-components)

ğŸ’Œ Tu comprends l'utilisation de `memo`

## Extra 3 - Composant dans un composant !

Voici un anti-pattern trÃ¨s gÃªnant !

Il **ne faut jamais mettre un composant dans un autre composant** en
utilisant la syntaxe que j'ai utilisÃ© dans l'`06.extra.3.jsx` !

Regarde : change la valeur de l'input puis clique sur le bouton !

Boom ğŸ’¥ la valeur est redevenue ce qu'elle Ã©tait.

Il faut donc mettre le composant `HeaderInput` en dehors du composant
`Header`.

ğŸ’Œ Tu comprends pourquoi il ne vaut pas instancier des composants dans des composants.

## Extra 4 - Children

On l'a dÃ©jÃ  vu dans l'exercice du `useEffect` mais j'ai envie de le
souligner.

Encore une fois il faut **abuser** de la crÃ©ation de composant.

Ici chaque fois que la page est scroll toute notre app est rerender
alors que uniquement le bouton change.

Pour que tu vois le lag j'ai crÃ©e un composant qui gÃ©nÃ¨re 10'000 nombres
alÃ©atoires Ã  chaque render. Tu verras que ton navigateur n'aime pas trop...

Tu peux crÃ©er un composant `ScrollComponent` qui contient deux props :

- `topChildren`
- `children`

Et tu peux donc remplacer notre app avec ces composant et mettre `SmallComponentTop`
ainsi que `ExpensiveComponent` dans les props.

## Extra 5 - useMemo

Cette application calcule les nombres premier et affiche ensuite
un composant par nombre premier trouvÃ©.

âš ï¸ Afin de mieux voir le lag, tu peux afficher l'inspecteur d'Ã©lÃ©ment.

Quand tu cliques sur le counter en haut tu verras un petit temps de latence,
tu auras l'impression que ton ordinateur bug pendant 1 seconde.

C'est car Ã  chaque fois que tu cliques sur ce bouton, ton ordinateur
recalcule les nombres premiers et rÃ©gÃ©nÃ¨re **tout** les composants.

Tu as deux missions : mÃ©moriser les nombres premiers pour
qu'ils ne se calculent que quand `max` (qui correspond aux nombre dans
l'input) change.

Il faut aussi **mÃ©moriser** le composant **PrimeNumber** afin d'Ã©viter
de les render tous Ã  chaque fois qu'on recalcule notre composant.

Dans le cas oÃ¹ tu as une liste avec des composants expensive (ce qui
n'est pas notre cas) il est intÃ©ressant de `memo` le composant
de la liste pour Ã©viter des calcules inutiles.

- ğŸ’Œ Tu apprends Ã  utiliser `useMemo` pour Ã©viter des calcules gourmands
- ğŸ’Œ Tu apprends Ã  `memo` un composant de liste pour Ã©viter les rerenders
