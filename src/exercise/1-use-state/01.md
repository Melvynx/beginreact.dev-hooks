# useState

`useState` est le hook **le plus utilisÃ©** dans React (et le plus simple).

Il a un seul but :

> Garder un Ã©tat dans un composant synchronisÃ© avec l'interface.

Pour faire en sorte que ton composant soit toujours Ã  jour, il faut que React
connaisse le moment oÃ¹ tu update le state. C'est pour cette raison que la crÃ©ation
d'un state se fait avec :

```js
const [state, setState] = useState(initialState);
```

`useState` retourne un tableau de deux Ã©lÃ©ments :

- Le `current state` de cette variable, que l'`initial state` dÃ©finit par dÃ©faut
- La `set function` qui va changer le state avec n'importe quelle autre valeur.

Donc pour update le state il faut utiliser `setState(newState)`.

[ğŸ“– useState](https://react.dev/reference/react/useState)

## Exercice 1 - Simple useState

Ajoute un state pour que l'application te dise bonjour avec ton nom en temps rÃ©el.

Instructions dans le fichier.

- ğŸ’Œ Tu comprends comment basiquement crÃ©er un state.

## Extra 2 - Ajout d'un nouveau state

Ajoute une checkbox qui, quand elle est activÃ©e, va afficher le prÃ©nom **inversÃ©**.

- Melvyn -> nyvyleM
- Jean -> naeJ

ğŸ¦ Tu peux ajouter une checkbox (`<input type="checkbox" />`) **controller**.

Attention, il te faut rajouter un nouveau state.
Et Ã  aucun moment il faut inverser la valeur du state `name` (non pas que ce serait
une erreur, juste que ce n'est pas mon but avec mon exercice).

[ğŸ“– Comment inverser une string en JS](https://www.youtube.com/watch?v=ygP1PMkDz0I)

- ğŸ’Œ Tu apprends ici Ã  gÃ©rer un affichage d'Ã©tat en fonction d'autres Ã©tats.
- ğŸ’Œ Tu apprends aussi Ã  gÃ©rer un boolean en fonction de sa valeur prÃ©cÃ©dente.

## Extra 3 - Stocker chaque changement de notre state

Notre state change, il faut stocker ce changement dans un autre state et les
afficher sous forme de liste

```jsx
<ul>
  {nameHistory.map((name, i) => (
    <li key={i}>{name}</li>
  ))}
</ul>
```

ğŸ’¡ Je mets `key={i}` et pas `key={name}` car notre liste ne change jamais d'ordre
et qu'un nom peut revenir plusieurs fois.

ğŸ’¡ Il ne faut pas utiliser `nameHistory.push`.

[ğŸ“– Alors comment faire ?](https://bobbyhadz.com/blog/react-push-to-state-array)

- ğŸ’Œ Tu apprends Ã  ajouter dans une liste.
- ğŸ’Œ Tu comprendras le lifecycle des hooks avec un bug expliquÃ©.

## Extra 4 - Supprimer des "NameHistory"

Quand tu cliques sur un historique, tu vas supprimer celui-ci de la liste.

```jsx
<ul>
  {nameHistory.map((name, i) => (
    <li key={i} onClick={() => deleteHistory(i)}>
      {name}
    </li>
  ))}
</ul>
```

Il te faut rajouter la fonction `deleteHistory` qui va supprimer le bon Ã©lÃ©ment
de la liste en fonction de l'index.

âš ï¸ Notre composant devient **complexe**. CrÃ©e un hooks `useStateHistory`
et met tout ce qui a un rapport avec l'historique dedans.

- ğŸ’Œ Tu apprends Ã  supprimer dans une liste.
- ğŸ’Œ Tu apprends Ã  correctement utiliser les custom hooks.

---

## Exercice 5 - OÃ¹ mettre les states ?

âš ï¸ Tu dois aller dans le fichier `Exercise1-5.jsx`, ce n'est pas la suite
de ce qu'on a fait jusqu'ici et ouvrir
["L'exercise 2"](http://127.0.0.1:5173/1-use-state/exercise/2) pour voir le rendu âš ï¸

En React, un des skill le plus important, **c'est de savoir oÃ¹ mettre les states**,
et c'est une Ã©norme source d'erreur.

Je t'explique le context, je viens de crÃ©er l'application la plus
mal faite possible.

**Ton but : la rÃ©parer.**

_1er problÃ¨me :_

Dans la section "Animal", quand on change le "Favorite animal", rien ne change
dans le text en dessous. Met le state au bon endroit pour rÃ©parer afin que l'Ã©lÃ©ment
en dessous se mette Ã  jour.

Et crÃ©e un nouveau composant `UserAnimalForm` qui possÃ¨de nos deux states et le
texte `Greeting`.

- ğŸ’Œ Tu comprends comment utiliser `useState` dans une application.

## Extra 6 - Refactor... Again

Deux concepts Ã  comprendre :

- Les donnÃ©es vont d'en haut Ã  en bas !
- Les states doivent Ãªtre le plus proche possible de leur utilisation

Quand tu vois la todo list, ce n'est vraiment pas le cas. Elle rerender
toute notre app Ã  chaque nouvelle todo car son Ã©tat est dans `App`.

Ton objectif est de crÃ©er un nouveau composant `TodoList` avec le state `todos`
Ã  l'intÃ©rieur ainsi que tous les composants qui sont liÃ©s aux todos.

Pourquoi ?

Car ce state n'est ni utilisÃ© par notre `UserAnimalForm` ni par
notre `Counter`.

Donc il n'a pas sa place ici.

Dans notre composant `TodoList` on peut sÃ©parer la logique des `todos`
dans un **custom hooks** qui contiendra le state ainsi que les fonctions
`addTodo` par exemple.

- ğŸ’Œ Tu comprends qu'il faut rÃ©partir les states au plus proche de leur
  usage dans des petits composants.

## Extra 7 - Refactor... Again

MÃªme chose pour Counter.

Tu peux simplement dÃ©placer le state `count` dans le composant "Counter".

Effectivement, le state `count` **n'est utilisÃ© que dans `Counter`** ! Il n'a
pas sa place dans `App` mais dans `Counter`.

Voici Ã  quoi devrait ressembler le composant App :

```jsx
const App = () => {
  return (
    <div>
      <Todo />
      <h2>Counter</h2>
      <Counter />
      <UserAnimalForm />
    </div>
  );
};
```

- ğŸ’Œ MÃªme les petits composants peuvent avoir un state si nÃ©cessaire.

## Conclusion

Effectivement, ce genre d'exercice ne s'approche pas de cas rÃ©els. Ce qui est intÃ©ressant
avec le premier exercice c'est de comprendre **comment** `useState` fonctionne
mÃªme si on dÃ©couvrira de nouvelles choses par la suite.

Le second exercice permet quant Ã  lui de **comprendre** et avoir la philosophie de
sÃ©parer les composants correctement.

J'ai vu tellement d'applications avec des states globaux alors qu'on aurait pu les
dÃ©placer dans les enfants. Je souhaite vraiment que tu aies compris ce concept.
